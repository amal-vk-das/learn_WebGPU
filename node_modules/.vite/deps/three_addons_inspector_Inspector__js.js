import {
  renderOutput,
  vec3,
  vec4
} from "./chunk-JVMZMAO3.js";
import {
  CanvasTarget,
  InspectorBase,
  NodeMaterial,
  QuadMesh,
  RendererUtils
} from "./chunk-S6D6VVQH.js";
import "./chunk-7C452AZX.js";
import {
  EventDispatcher,
  LinearSRGBColorSpace,
  NoToneMapping,
  REVISION,
  TimestampQuery,
  setConsoleFunction
} from "./chunk-2KNTCVP2.js";

// node_modules/three/examples/jsm/inspector/RendererInspector.js
var ObjectStats = class {
  constructor(uid, name) {
    this.uid = uid;
    this.cid = uid.match(/^(.*):f(\d+)$/)[1];
    this.name = name;
    this.timestamp = 0;
    this.cpu = 0;
    this.gpu = 0;
    this.fps = 0;
    this.children = [];
    this.parent = null;
  }
};
var RenderStats = class extends ObjectStats {
  constructor(uid, scene, camera, renderTarget) {
    let name = scene.name;
    if (name === "") {
      if (scene.isScene) {
        name = "Scene";
      } else if (scene.isQuadMesh) {
        name = "QuadMesh";
      }
    }
    super(uid, name);
    this.scene = scene;
    this.camera = camera;
    this.renderTarget = renderTarget;
    this.isRenderStats = true;
  }
};
var ComputeStats = class extends ObjectStats {
  constructor(uid, computeNode) {
    super(uid, computeNode.name);
    this.computeNode = computeNode;
    this.isComputeStats = true;
  }
};
var RendererInspector = class extends InspectorBase {
  constructor() {
    super();
    this.currentFrame = null;
    this.currentRender = null;
    this.currentNodes = null;
    this.lastFrame = null;
    this.frames = [];
    this.framesLib = {};
    this.maxFrames = 512;
    this._lastFinishTime = 0;
    this._resolveTimestampPromise = null;
    this.isRendererInspector = true;
  }
  getParent() {
    return this.currentRender || this.getFrame();
  }
  begin() {
    this.currentFrame = this._createFrame();
    this.currentRender = this.currentFrame;
    this.currentNodes = [];
  }
  finish() {
    const now = performance.now();
    const frame = this.currentFrame;
    frame.finishTime = now;
    frame.deltaTime = now - (this._lastFinishTime > 0 ? this._lastFinishTime : now);
    this.addFrame(frame);
    this.fps = this._getFPS();
    this.lastFrame = frame;
    this.currentFrame = null;
    this.currentRender = null;
    this.currentNodes = null;
    this._lastFinishTime = now;
  }
  _getFPS() {
    let frameSum = 0;
    let timeSum = 0;
    for (let i = this.frames.length - 1; i >= 0; i--) {
      const frame = this.frames[i];
      frameSum++;
      timeSum += frame.deltaTime;
      if (timeSum >= 1e3) break;
    }
    return frameSum * 1e3 / timeSum;
  }
  _createFrame() {
    return {
      frameId: this.nodeFrame.frameId,
      resolvedCompute: false,
      resolvedRender: false,
      deltaTime: 0,
      startTime: performance.now(),
      finishTime: 0,
      miscellaneous: 0,
      children: [],
      renders: [],
      computes: []
    };
  }
  getFrame() {
    return this.currentFrame || this.lastFrame;
  }
  getFrameById(frameId) {
    return this.framesLib[frameId] || null;
  }
  resolveViewer() {
  }
  resolveFrame() {
  }
  async resolveTimestamp() {
    if (this._resolveTimestampPromise !== null) {
      return this._resolveTimestampPromise;
    }
    this._resolveTimestampPromise = new Promise((resolve) => {
      requestAnimationFrame(async () => {
        const renderer = this.getRenderer();
        await renderer.resolveTimestampsAsync(TimestampQuery.COMPUTE);
        await renderer.resolveTimestampsAsync(TimestampQuery.RENDER);
        const computeFrames = renderer.backend.getTimestampFrames(TimestampQuery.COMPUTE);
        const renderFrames = renderer.backend.getTimestampFrames(TimestampQuery.RENDER);
        const frameIds = [.../* @__PURE__ */ new Set([...computeFrames, ...renderFrames])];
        for (const frameId of frameIds) {
          const frame = this.getFrameById(frameId);
          if (frame !== null) {
            if (frame.resolvedCompute === false) {
              if (frame.computes.length > 0) {
                if (computeFrames.includes(frameId)) {
                  for (const stats of frame.computes) {
                    if (renderer.backend.hasTimestamp(stats.uid)) {
                      stats.gpu = renderer.backend.getTimestamp(stats.uid);
                    } else {
                      stats.gpu = 0;
                      stats.gpuNotAvailable = true;
                    }
                  }
                  frame.resolvedCompute = true;
                }
              } else {
                frame.resolvedCompute = true;
              }
            }
            if (frame.resolvedRender === false) {
              if (frame.renders.length > 0) {
                if (renderFrames.includes(frameId)) {
                  for (const stats of frame.renders) {
                    if (renderer.backend.hasTimestamp(stats.uid)) {
                      stats.gpu = renderer.backend.getTimestamp(stats.uid);
                    } else {
                      stats.gpu = 0;
                      stats.gpuNotAvailable = true;
                    }
                  }
                  frame.resolvedRender = true;
                }
              } else {
                frame.resolvedRender = true;
              }
            }
            if (frame.resolvedCompute === true && frame.resolvedRender === true) {
              this.resolveFrame(frame);
            }
          }
        }
        this._resolveTimestampPromise = null;
        resolve();
      });
    });
    return this._resolveTimestampPromise;
  }
  get isAvailable() {
    const renderer = this.getRenderer();
    return renderer !== null;
  }
  addFrame(frame) {
    if (this.frames.length >= this.maxFrames) {
      const removedFrame = this.frames.shift();
      delete this.framesLib[removedFrame.frameId];
    }
    this.frames.push(frame);
    this.framesLib[frame.frameId] = frame;
    if (this.isAvailable) {
      this.resolveViewer();
      this.resolveTimestamp();
    }
  }
  inspect(node) {
    this.currentNodes.push(node);
  }
  beginCompute(uid, computeNode) {
    const frame = this.getFrame();
    if (!frame) return;
    const currentCompute = new ComputeStats(uid, computeNode);
    currentCompute.timestamp = performance.now();
    currentCompute.parent = this.currentCompute || this.getParent();
    frame.computes.push(currentCompute);
    if (this.currentRender !== null) {
      this.currentRender.children.push(currentCompute);
    } else {
      frame.children.push(currentCompute);
    }
    this.currentCompute = currentCompute;
  }
  finishCompute() {
    const frame = this.getFrame();
    if (!frame) return;
    const currentCompute = this.currentCompute;
    currentCompute.cpu = performance.now() - currentCompute.timestamp;
    this.currentCompute = currentCompute.parent.isComputeStats ? currentCompute.parent : null;
  }
  beginRender(uid, scene, camera, renderTarget) {
    const frame = this.getFrame();
    if (!frame) return;
    const currentRender = new RenderStats(uid, scene, camera, renderTarget);
    currentRender.timestamp = performance.now();
    currentRender.parent = this.getParent();
    frame.renders.push(currentRender);
    if (this.currentRender !== null) {
      this.currentRender.children.push(currentRender);
    } else {
      frame.children.push(currentRender);
    }
    this.currentRender = currentRender;
  }
  finishRender() {
    const frame = this.getFrame();
    if (!frame) return;
    const currentRender = this.currentRender;
    currentRender.cpu = performance.now() - currentRender.timestamp;
    this.currentRender = currentRender.parent;
  }
};

// node_modules/three/examples/jsm/inspector/ui/Style.js
var Style = class {
  static init() {
    if (document.getElementById("profiler-styles")) return;
    const css = `
:root {
	--profiler-bg: #1e1e24f5;
	--profiler-header-bg: #2a2a33aa;
	--profiler-header: #2a2a33;
	--profiler-border: #4a4a5a;
	--text-primary: #e0e0e0;
	--text-secondary: #9a9aab;
	--accent-color: #00aaff;
	--color-green: #4caf50;
	--color-yellow: #ffc107;
	--color-red: #f44336;
	--font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
	--font-mono: 'Fira Code', 'Courier New', Courier, monospace;
}

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Fira+Code&display=swap');

#profiler-panel *, #profiler-toggle * {
	text-transform: initial;
	line-height: normal;
	box-sizing: border-box;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

#profiler-toggle {
	position: fixed;
	top: 15px;
	right: 15px;
	background-color: rgba(30, 30, 36, 0.85);
	border: 1px solid #4a4a5a54;
	border-radius: 6px 12px 12px 6px;
	color: var(--text-primary);
	cursor: pointer;
	z-index: 1001;
	transition: all 0.2s ease-in-out;
	font-size: 14px;
	backdrop-filter: blur(8px);
	box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
	display: flex;
	align-items: stretch;
	padding: 0;
	overflow: hidden;
	font-family: var(--font-family);
}

#profiler-toggle:hover {
	border-color: var(--accent-color);
}

#profiler-toggle.hidden {
	opacity: 0;
	pointer-events: none;
}

#toggle-icon {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 40px;
	font-size: 20px;
	transition: background-color 0.2s;
}

#profiler-toggle:hover #toggle-icon {
	background-color: rgba(255, 255, 255, 0.05);
}

.toggle-separator {
	width: 1px;
	background-color: var(--profiler-border);
}

#toggle-text {
	display: flex;
	align-items: baseline;
	padding: 8px 14px;
	min-width: 80px;
	justify-content: right;
}

#toggle-text .fps-label {
	font-size: 0.7em;
	margin-left: 10px;
    color: #999;
}

#profiler-panel {
	position: fixed;
	z-index: 1001 !important;
	bottom: 0;
	left: 0;
	right: 0;
	height: 350px;
	background-color: var(--profiler-bg);
	backdrop-filter: blur(8px);
	border-top: 2px solid var(--profiler-border);
	color: var(--text-primary);
	display: flex;
	flex-direction: column;
	z-index: 1000;
	/*box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.5);*/
	transform: translateY(100%);
	transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94), height 0.3s ease-out;
	font-family: var(--font-mono);
}

#profiler-panel.resizing {
	transition: none;
}

#profiler-panel.visible {
	transform: translateY(0);
}

#profiler-panel.maximized {
	height: 100vh;
}


.panel-resizer {
	position: absolute;
	top: -2px;
	left: 0;
	width: 100%;
	height: 5px;
	cursor: ns-resize;
	z-index: 1001;
}

.profiler-header {
	display: flex;
	background-color: var(--profiler-header-bg);
	border-bottom: 1px solid var(--profiler-border);
	flex-shrink: 0;
	justify-content: space-between;
	align-items: stretch;

	overflow-x: auto;
	overflow-y: hidden;
	width: calc(100% - 89px);
	height: 38px;
}

.profiler-tabs {
	display: flex;
}

.profiler-controls {
	display: flex;
	position: absolute;
	right: 0;
	top: 0;
	height: 38px;
	background: var(--profiler-header-bg);
	border-bottom: 1px solid var(--profiler-border);
}

.tab-btn {
	background: transparent;
	border: none;
	/*border-right: 1px solid var(--profiler-border);*/
	color: var(--text-secondary);
	padding: 8px 18px;
	cursor: pointer;
	display: flex;
	align-items: center;
	font-family: var(--font-family);
    font-weight: 600;
	font-size: 14px;
}

.tab-btn.active {
    border-bottom: 2px solid var(--accent-color);
	color: white;
}

#maximize-btn,
#hide-panel-btn {
	background: transparent;
	border: none;
	border-left: 1px solid var(--profiler-border);
	color: var(--text-secondary);
	width: 45px;
	cursor: pointer;
	transition: all 0.2s;
	display: flex;
	align-items: center;
	justify-content: center;
}

#maximize-btn:hover,
#hide-panel-btn:hover {
	background-color: rgba(255, 255, 255, 0.1);
	color: var(--text-primary);
}

.profiler-content-wrapper {
	flex-grow: 1;
	overflow: hidden;
	position: relative;
}

.profiler-content {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	overflow-y: auto;
	font-size: 13px;
	visibility: hidden;
	opacity: 0;
	transition: opacity 0.2s, visibility 0.2s;
	box-sizing: border-box;
	display: flex;
	flex-direction: column;
}

.profiler-content.active {
	visibility: visible;
	opacity: 1;
}

.profiler-content {
	overflow: auto; /* make sure scrollbars can appear */
}

.profiler-content::-webkit-scrollbar {
	width: 8px;
	height: 8px;
}

.profiler-content::-webkit-scrollbar-track {
	background: transparent;
}

.profiler-content::-webkit-scrollbar-thumb {
	background-color: rgba(0, 0, 0, 0.25);
	border-radius: 10px;
	transition: background 0.3s ease;
}

.profiler-content::-webkit-scrollbar-thumb:hover {
	background-color: rgba(0, 0, 0, 0.4);
}

.profiler-content::-webkit-scrollbar-corner {
	background: transparent;
}

.profiler-content {
	scrollbar-width: thin; /* "auto" | "thin" */
	scrollbar-color: rgba(0, 0, 0, 0.25) transparent;
}

.list-item-row {
	display: grid;
	align-items: center;
	padding: 4px 8px;
	border-radius: 3px;
	transition: background-color 0.2s;
	gap: 10px;
	border-bottom: none;
}

.list-item-wrapper {
	margin-top: 2px;
	margin-bottom: 2px;
}

.list-item-wrapper:first-child {
	/*margin-top: 0;*/
}

.list-item-wrapper:not(.header-wrapper):nth-child(odd) > .list-item-row {
	background-color: rgba(0,0,0,0.1);
}

.list-item-wrapper.header-wrapper>.list-item-row {
	color: var(--accent-color);
	background-color: rgba(0, 170, 255, 0.1);
}

.list-item-wrapper.header-wrapper>.list-item-row>.list-item-cell:first-child {
	font-weight: 600;
}

.list-item-row.collapsible,
.list-item-row.actionable {
	cursor: pointer;
}

.list-item-row.collapsible {
	background-color: rgba(0, 170, 255, 0.15) !important;
}

.list-item-row.collapsible.alert,
.list-item-row.alert {
	background-color: rgba(244, 67, 54, 0.1) !important;
}

@media (hover: hover) {

	.list-item-row:hover:not(.collapsible):not(.no-hover),
	.list-item-row:hover:not(.no-hover),
	.list-item-row.actionable:hover,
	.list-item-row.collapsible.actionable:hover {
		background-color: rgba(255, 255, 255, 0.05) !important;
	}

	.list-item-row.collapsible:hover {
		background-color: rgba(0, 170, 255, 0.25) !important;
	}

}

.list-item-cell {
	white-space: pre;
	display: flex;
	align-items: center;
}

.list-item-cell:not(:first-child) {
	justify-content: flex-end;
	font-weight: 600;
}

.list-header {
	display: grid;
	align-items: center;
	padding: 4px 8px;
	font-weight: 600;
	color: var(--text-secondary);
	padding-bottom: 6px;
	border-bottom: 1px solid var(--profiler-border);
	margin-bottom: 5px;
	gap: 10px;
}

.list-item-wrapper.section-start {
	margin-top: 5px;
	margin-bottom: 5px;
}

.list-header .list-header-cell:not(:first-child) {
	text-align: right;
}

.list-children-container {
	padding-left: 1.5em;
	overflow: hidden;
	transition: max-height 0.1s ease-out;
	margin-top: 2px;
}

.list-children-container.closed {
	max-height: 0;
}

.item-toggler {
	display: inline-block;
	margin-right: 0.8em;
	text-align: left;
}

.list-item-row.open .item-toggler::before {
	content: '-';
}

.list-item-row:not(.open) .item-toggler::before {
	content: '+';
}

.list-item-cell .value.good {
	color: var(--color-green);
}

.list-item-cell .value.warn {
	color: var(--color-yellow);
}

.list-item-cell .value.bad {
	color: var(--color-red);
}

.list-scroll-wrapper {
	overflow-x: auto;
	width: 100%;
}

.list-container.parameters .list-item-row:not(.collapsible) {
	height: 31px;
}

.graph-container {
	width: 100%;
	box-sizing: border-box;
	padding: 8px 0;
	position: relative;
}

.graph-svg {
	width: 100%;
	height: 80px;
	background-color: var(--profiler-header);
	border: 1px solid var(--profiler-border);
	border-radius: 4px;
}

.graph-path {
	stroke-width: 2;
	fill-opacity: 0.4;
}

.console-header {
	padding: 10px;
	border-bottom: 1px solid var(--profiler-border);
	display: flex;
	gap: 20px;
	flex-shrink: 0;
	align-items: center;
	justify-content: space-between;
}

.console-filters-group {
	display: flex;
	gap: 20px;
}

.console-filter-input {
	background-color: var(--profiler-bg);
	border: 1px solid var(--profiler-border);
	color: var(--text-primary);
	border-radius: 4px;
	padding: 4px 8px;
	font-family: var(--font-mono);
	flex-grow: 1;
	max-width: 300px;
	border-radius: 15px;
}

#console-log {
	display: flex;
	flex-direction: column;
	gap: 4px;
	padding: 10px;
	overflow-y: auto;
	flex-grow: 1;
}

.log-message {
	padding: 2px 5px;
	white-space: pre-wrap;
	word-break: break-all;
	border-radius: 3px;
	line-height: 1.5 !important;
}

.log-message.hidden {
	display: none;
}

.log-message.info {
	color: var(--text-primary);
}

.log-message.warn {
	color: var(--color-yellow);
}

.log-message.error {
	color: #f9dedc;
	background-color: rgba(244, 67, 54, 0.1);
}

.log-prefix {
	color: var(--text-secondary);
	margin-right: 8px;
}

.log-code {
	background-color: rgba(255, 255, 255, 0.1);
	border-radius: 3px;
	padding: 1px 4px;
}

.thumbnail-container {
	display: flex;
	align-items: center;
}

.thumbnail-svg {
	width: 40px;
	height: 22.5px;
	flex-shrink: 0;
	margin-right: 8px;
}

.param-control {
	display: flex;
	align-items: center;
	justify-content: flex-end;
	gap: 10px;
	width: 100%;
}

.param-control input,
.param-control select,
.param-control button {
	background-color: var(--profiler-bg);
	border: 1px solid var(--profiler-border);
	color: var(--text-primary);
	border-radius: 4px;
	padding: 4px 6px;
	padding-bottom: 2px;
	font-family: var(--font-mono);
	width: 100%;
	box-sizing: border-box;
}

.param-control select {
	padding-top: 3px;
	padding-bottom: 1px;
}

.param-control input[type="number"] {
	cursor: ns-resize;
}

.param-control input[type="color"] {
	padding: 2px;
}

.param-control button {
	cursor: pointer;
	transition: background-color 0.2s;
}

.param-control button:hover {
	background-color: var(--profiler-header);
}

.param-control-vector {
	display: flex;
	gap: 5px;
}

.custom-checkbox {
	display: inline-flex;
	align-items: center;
	cursor: pointer;
	gap: 8px;
}

.custom-checkbox input {
	display: none;
}

.custom-checkbox .checkmark {
	width: 14px;
	height: 14px;
	border: 1px solid var(--profiler-border);
	border-radius: 3px;
	display: inline-flex;
	justify-content: center;
	align-items: center;
	transition: background-color 0.2s, border-color 0.2s;
}

.custom-checkbox .checkmark::after {
	content: '';
	width: 8px;
	height: 8px;
	background-color: var(--accent-color);
	border-radius: 1px;
	display: block;
	transform: scale(0);
	transition: transform 0.2s;
}

.custom-checkbox input:checked+.checkmark {
	border-color: var(--accent-color);
}

.custom-checkbox input:checked+.checkmark::after {
	transform: scale(1);
}

.param-control input[type="range"] {
	-webkit-appearance: none;
	appearance: none;
	width: 100%;
	height: 16px;
	background: var(--profiler-header);
	border-radius: 5px;
	border: 1px solid var(--profiler-border);
	outline: none;
	padding: 0px;
	padding-top: 8px;
}

.param-control input[type="range"]::-webkit-slider-thumb {
	-webkit-appearance: none;
	appearance: none;
	width: 18px;
	height: 18px;
	background: var(--profiler-bg);
	border: 1px solid var(--accent-color);
	border-radius: 3px;
	cursor: pointer;
	margin-top: -8px;
}

.param-control input[type="range"]::-moz-range-thumb {
	width: 18px;
	height: 18px;
	background: var(--profiler-bg);
	border: 2px solid var(--accent-color);
	border-radius: 3px;
	cursor: pointer;
}

.param-control input[type="range"]::-moz-range-track {
	width: 100%;
	height: 16px;
	background: var(--profiler-header);
	border-radius: 5px;
	border: 1px solid var(--profiler-border);
}

@media screen and (max-width: 768px) and (orientation: portrait) {

	.console-filter-input {
		max-width: 100px;
	}

}
`;
    const styleElement = document.createElement("style");
    styleElement.id = "profiler-styles";
    styleElement.textContent = css;
    document.head.appendChild(styleElement);
  }
};

// node_modules/three/examples/jsm/inspector/ui/Profiler.js
var Profiler = class {
  constructor() {
    this.tabs = {};
    this.activeTabId = null;
    this.isResizing = false;
    this.lastHeight = 350;
    Style.init();
    this.setupShell();
    this.setupResizing();
  }
  setupShell() {
    this.domElement = document.createElement("div");
    this.domElement.id = "profiler-shell";
    this.toggleButton = document.createElement("button");
    this.toggleButton.id = "profiler-toggle";
    this.toggleButton.innerHTML = `
<span id="toggle-text">
	<span id="fps-counter">-</span>
	<span class="fps-label">FPS</span>
</span>
<!-- <span class="toggle-separator"></span> -->
<span id="toggle-icon">
	<svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-device-ipad-horizontal-search"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11.5 20h-6.5a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v5.5" /><path d="M9 17h2" /><path d="M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" /><path d="M20.2 20.2l1.8 1.8" /></svg>
</span>
`;
    this.toggleButton.onclick = () => this.togglePanel();
    this.panel = document.createElement("div");
    this.panel.id = "profiler-panel";
    const header = document.createElement("div");
    header.className = "profiler-header";
    this.tabsContainer = document.createElement("div");
    this.tabsContainer.className = "profiler-tabs";
    const controls = document.createElement("div");
    controls.className = "profiler-controls";
    this.maximizeBtn = document.createElement("button");
    this.maximizeBtn.id = "maximize-btn";
    this.maximizeBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>';
    this.maximizeBtn.onclick = () => this.toggleMaximize();
    const hideBtn = document.createElement("button");
    hideBtn.id = "hide-panel-btn";
    hideBtn.textContent = "-";
    hideBtn.onclick = () => this.togglePanel();
    controls.append(this.maximizeBtn, hideBtn);
    header.append(this.tabsContainer, controls);
    this.contentWrapper = document.createElement("div");
    this.contentWrapper.className = "profiler-content-wrapper";
    const resizer = document.createElement("div");
    resizer.className = "panel-resizer";
    this.panel.append(resizer, header, this.contentWrapper);
    this.domElement.append(this.toggleButton, this.panel);
  }
  setupResizing() {
    const resizer = this.panel.querySelector(".panel-resizer");
    const onStart = (e) => {
      this.isResizing = true;
      this.panel.classList.add("resizing");
      const startY = e.clientY || e.touches[0].clientY;
      const startHeight = this.panel.offsetHeight;
      const onMove = (moveEvent) => {
        if (!this.isResizing) return;
        moveEvent.preventDefault();
        const currentY = moveEvent.clientY || moveEvent.touches[0].clientY;
        const newHeight = startHeight - (currentY - startY);
        if (newHeight > 100 && newHeight < window.innerHeight - 50) {
          this.panel.style.height = `${newHeight}px`;
        }
      };
      const onEnd = () => {
        this.isResizing = false;
        this.panel.classList.remove("resizing");
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onEnd);
        document.removeEventListener("touchmove", onMove);
        document.removeEventListener("touchend", onEnd);
        if (!this.panel.classList.contains("maximized")) {
          this.lastHeight = this.panel.offsetHeight;
        }
      };
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onEnd);
      document.addEventListener("touchmove", onMove, { passive: false });
      document.addEventListener("touchend", onEnd);
    };
    resizer.addEventListener("mousedown", onStart);
    resizer.addEventListener("touchstart", onStart);
  }
  toggleMaximize() {
    if (this.panel.classList.contains("maximized")) {
      this.panel.classList.remove("maximized");
      this.panel.style.height = `${this.lastHeight}px`;
      this.maximizeBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>';
    } else {
      this.lastHeight = this.panel.offsetHeight;
      this.panel.classList.add("maximized");
      this.panel.style.height = "100vh";
      this.maximizeBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="8" width="12" height="12" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg>';
    }
  }
  addTab(tab) {
    this.tabs[tab.id] = tab;
    tab.button.onclick = () => this.setActiveTab(tab.id);
    this.tabsContainer.appendChild(tab.button);
    this.contentWrapper.appendChild(tab.content);
  }
  setActiveTab(id) {
    if (this.activeTabId) this.tabs[this.activeTabId].setActive(false);
    this.activeTabId = id;
    this.tabs[id].setActive(true);
  }
  togglePanel() {
    this.panel.classList.toggle("visible");
    this.toggleButton.classList.toggle("hidden");
  }
};

// node_modules/three/examples/jsm/inspector/ui/Tab.js
var Tab = class {
  constructor(title) {
    this.id = title.toLowerCase();
    this.button = document.createElement("button");
    this.button.className = "tab-btn";
    this.button.textContent = title;
    this.content = document.createElement("div");
    this.content.id = `${this.id}-content`;
    this.content.className = "profiler-content";
    this.isActive = false;
    this.isVisible = true;
  }
  setActive(isActive) {
    this.button.classList.toggle("active", isActive);
    this.content.classList.toggle("active", isActive);
    this.isActive = isActive;
  }
  show() {
    this.content.style.display = "";
    this.button.style.display = "";
    this.isVisible = true;
  }
  hide() {
    this.content.style.display = "none";
    this.button.style.display = "none";
    this.isVisible = false;
  }
};

// node_modules/three/examples/jsm/inspector/ui/List.js
var List = class {
  constructor(...headers) {
    this.headers = headers;
    this.children = [];
    this.domElement = document.createElement("div");
    this.domElement.className = "list-container";
    this.domElement.style.padding = "10px";
    this.id = `list-${Math.random().toString(36).substr(2, 9)}`;
    this.domElement.dataset.listId = this.id;
    this.gridStyleElement = document.createElement("style");
    this.domElement.appendChild(this.gridStyleElement);
    const headerRow = document.createElement("div");
    headerRow.className = "list-header";
    this.headers.forEach((headerText) => {
      const headerCell = document.createElement("div");
      headerCell.className = "list-header-cell";
      headerCell.textContent = headerText;
      headerRow.appendChild(headerCell);
    });
    this.domElement.appendChild(headerRow);
  }
  setGridStyle(gridTemplate) {
    this.gridStyleElement.textContent = `
[data-list-id="${this.id}"] > .list-header,
[data-list-id="${this.id}"] .list-item-row {
	grid-template-columns: ${gridTemplate};
}
`;
  }
  add(item) {
    if (item.parent !== null) {
      item.parent.remove(item);
    }
    item.domElement.classList.add("header-wrapper", "section-start");
    item.parent = this;
    this.children.push(item);
    this.domElement.appendChild(item.domElement);
  }
  remove(item) {
    const index = this.children.indexOf(item);
    if (index !== -1) {
      this.children.splice(index, 1);
      this.domElement.removeChild(item.domElement);
      item.parent = null;
    }
    return this;
  }
};

// node_modules/three/examples/jsm/inspector/ui/Graph.js
var Graph = class {
  constructor(maxPoints = 512) {
    this.maxPoints = maxPoints;
    this.lines = {};
    this.limit = 0;
    this.limitIndex = 0;
    this.domElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.domElement.setAttribute("class", "graph-svg");
  }
  addLine(id, color) {
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("class", "graph-path");
    path.style.stroke = `var(${color})`;
    path.style.fill = `var(${color})`;
    this.domElement.appendChild(path);
    this.lines[id] = { path, color, points: [] };
  }
  addPoint(lineId, value) {
    const line = this.lines[lineId];
    if (!line) return;
    line.points.push(value);
    if (line.points.length > this.maxPoints) {
      line.points.shift();
    }
    if (value > this.limit) {
      this.limit = value;
      this.limitIndex = 0;
    }
  }
  resetLimit() {
    this.limit = 0;
    this.limitIndex = 0;
  }
  update() {
    const svgWidth = this.domElement.clientWidth;
    const svgHeight = this.domElement.clientHeight;
    if (svgWidth === 0) return;
    const pointStep = svgWidth / (this.maxPoints - 1);
    for (const id in this.lines) {
      const line = this.lines[id];
      let pathString = `M 0,${svgHeight}`;
      for (let i = 0; i < line.points.length; i++) {
        const x = i * pointStep;
        const y = svgHeight - line.points[i] / this.limit * svgHeight;
        pathString += ` L ${x},${y}`;
      }
      pathString += ` L ${(line.points.length - 1) * pointStep},${svgHeight} Z`;
      const offset = svgWidth - (line.points.length - 1) * pointStep;
      line.path.setAttribute("transform", `translate(${offset}, 0)`);
      line.path.setAttribute("d", pathString);
    }
    if (this.limitIndex++ > this.maxPoints) {
      this.resetLimit();
    }
  }
};

// node_modules/three/examples/jsm/inspector/ui/Item.js
var Item = class {
  constructor(...data) {
    this.children = [];
    this.isOpen = true;
    this.childrenContainer = null;
    this.parent = null;
    this.domElement = document.createElement("div");
    this.domElement.className = "list-item-wrapper";
    this.itemRow = document.createElement("div");
    this.itemRow.className = "list-item-row";
    this.userData = {};
    this.data = data;
    this.data.forEach((cellData) => {
      const cell = document.createElement("div");
      cell.className = "list-item-cell";
      if (cellData instanceof HTMLElement) {
        cell.appendChild(cellData);
      } else {
        cell.append(String(cellData));
      }
      this.itemRow.appendChild(cell);
    });
    this.domElement.appendChild(this.itemRow);
    this.onItemClick = this.onItemClick.bind(this);
  }
  onItemClick(e) {
    if (e.target.closest("button, a, input, label")) return;
    this.toggle();
  }
  add(item, index = this.children.length) {
    if (item.parent !== null) {
      item.parent.remove(item);
    }
    item.parent = this;
    this.children.splice(index, 0, item);
    this.itemRow.classList.add("collapsible");
    if (!this.childrenContainer) {
      this.childrenContainer = document.createElement("div");
      this.childrenContainer.className = "list-children-container";
      this.childrenContainer.classList.toggle("closed", !this.isOpen);
      this.domElement.appendChild(this.childrenContainer);
      this.itemRow.addEventListener("click", this.onItemClick);
    }
    this.childrenContainer.insertBefore(
      item.domElement,
      this.childrenContainer.children[index] || null
    );
    this.updateToggler();
    return this;
  }
  remove(item) {
    const index = this.children.indexOf(item);
    if (index !== -1) {
      this.children.splice(index, 1);
      this.childrenContainer.removeChild(item.domElement);
      item.parent = null;
      if (this.children.length === 0) {
        this.itemRow.classList.remove("collapsible");
        this.itemRow.removeEventListener("click", this.onItemClick);
        this.childrenContainer.remove();
        this.childrenContainer = null;
      }
      this.updateToggler();
    }
    return this;
  }
  updateToggler() {
    const firstCell = this.itemRow.querySelector(".list-item-cell:first-child");
    let toggler = this.itemRow.querySelector(".item-toggler");
    if (this.children.length > 0) {
      if (!toggler) {
        toggler = document.createElement("span");
        toggler.className = "item-toggler";
        firstCell.prepend(toggler);
      }
      if (this.isOpen) {
        this.itemRow.classList.add("open");
      }
    } else if (toggler) {
      toggler.remove();
    }
  }
  toggle() {
    this.isOpen = !this.isOpen;
    this.itemRow.classList.toggle("open", this.isOpen);
    if (this.childrenContainer) {
      this.childrenContainer.classList.toggle("closed", !this.isOpen);
    }
    return this;
  }
  close() {
    if (this.isOpen) {
      this.toggle();
    }
    return this;
  }
};

// node_modules/three/examples/jsm/inspector/ui/utils.js
function createValueSpan(id = null) {
  const span = document.createElement("span");
  span.className = "value";
  if (id !== null) span.id = id;
  return span;
}
function setText(element, text) {
  const el = element instanceof HTMLElement ? element : document.getElementById(element);
  if (el && el.textContent !== text) {
    el.textContent = text;
  }
}
function splitPath(fullPath) {
  const lastSlash = fullPath.lastIndexOf("/");
  if (lastSlash === -1) {
    return {
      path: "",
      name: fullPath.trim()
    };
  }
  const path = fullPath.substring(0, lastSlash).trim();
  const name = fullPath.substring(lastSlash + 1).trim();
  return { path, name };
}
function splitCamelCase(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1 $2").trim();
}

// node_modules/three/examples/jsm/inspector/tabs/Performance.js
var Performance = class extends Tab {
  constructor() {
    super("Performance");
    const perfList = new List("Name", "CPU", "GPU", "Total");
    perfList.setGridStyle("minmax(200px, 2fr) 80px 80px 80px");
    perfList.domElement.style.minWidth = "600px";
    const scrollWrapper = document.createElement("div");
    scrollWrapper.className = "list-scroll-wrapper";
    scrollWrapper.appendChild(perfList.domElement);
    this.content.appendChild(scrollWrapper);
    const graphContainer = document.createElement("div");
    graphContainer.className = "graph-container";
    const graph = new Graph();
    graph.addLine("fps", "--accent-color");
    graphContainer.append(graph.domElement);
    const graphStats = new Item("Graph Stats", createValueSpan(), createValueSpan(), createValueSpan("graph-fps-counter"));
    perfList.add(graphStats);
    const graphItem = new Item(graphContainer);
    graphItem.itemRow.childNodes[0].style.gridColumn = "1 / -1";
    graphStats.add(graphItem);
    const frameStats = new Item("Frame Stats", createValueSpan(), createValueSpan(), createValueSpan());
    perfList.add(frameStats);
    const miscellaneous = new Item("Miscellaneous & Idle", createValueSpan(), createValueSpan(), createValueSpan());
    miscellaneous.domElement.firstChild.style.backgroundColor = "#00ff0b1a";
    miscellaneous.domElement.firstChild.classList.add("no-hover");
    frameStats.add(miscellaneous);
    this.notInUse = /* @__PURE__ */ new Map();
    this.frameStats = frameStats;
    this.graphStats = graphStats;
    this.graph = graph;
    this.miscellaneous = miscellaneous;
    this.currentRender = null;
    this.currentItem = null;
    this.frameItems = /* @__PURE__ */ new Map();
  }
  resolveStats(inspector, stats) {
    const data = inspector.getStatsData(stats.cid);
    let item = data.item;
    if (item === void 0) {
      item = new Item(createValueSpan(), createValueSpan(), createValueSpan(), createValueSpan());
      if (stats.name) {
        if (stats.isComputeStats === true) {
          stats.name = `${stats.name} [ Compute ]`;
        }
      } else {
        stats.name = `Unnamed ${stats.cid}`;
      }
      item.userData.name = stats.name;
      this.currentItem.add(item);
      data.item = item;
    } else {
      item.userData.name = stats.name;
      if (this.notInUse.has(stats.cid)) {
        item.domElement.firstElementChild.classList.remove("alert");
        this.notInUse.delete(stats.cid);
      }
      const statsIndex = stats.parent.children.indexOf(stats);
      if (item.parent === null || item.parent.children.indexOf(item) !== statsIndex) {
        this.currentItem.add(item, statsIndex);
      }
    }
    let name = item.userData.name;
    if (stats.isComputeStats) {
      name += " [ Compute ]";
    }
    setText(item.data[0], name);
    setText(item.data[1], data.cpu.toFixed(2));
    setText(item.data[2], stats.gpuNotAvailable === true ? "-" : data.gpu.toFixed(2));
    setText(item.data[3], data.total.toFixed(2));
    const previousItem = this.currentItem;
    this.currentItem = item;
    for (const child of stats.children) {
      this.resolveStats(inspector, child);
    }
    this.currentItem = previousItem;
    this.frameItems.set(stats.cid, item);
  }
  updateGraph(inspector) {
    this.graph.addPoint("fps", inspector.fps);
    this.graph.update();
  }
  addNotInUse(cid, item) {
    item.domElement.firstElementChild.classList.add("alert");
    this.notInUse.set(cid, {
      item,
      time: performance.now()
    });
    this.updateNotInUse(cid);
  }
  updateNotInUse(cid) {
    const { item, time } = this.notInUse.get(cid);
    const current = performance.now();
    const duration = 5;
    const remaining = duration - Math.floor((current - time) / 1e3);
    if (remaining >= 0) {
      const counter = "*".repeat(Math.max(0, remaining));
      const element = item.domElement.querySelector(".list-item-cell .value");
      setText(element, item.userData.name + " (not in use) " + counter);
    } else {
      item.domElement.firstElementChild.classList.remove("alert");
      item.parent.remove(item);
      this.notInUse.delete(cid);
    }
  }
  updateText(inspector, frame) {
    const oldFrameItems = new Map(this.frameItems);
    this.frameItems.clear();
    this.currentItem = this.frameStats;
    for (const child of frame.children) {
      this.resolveStats(inspector, child);
    }
    for (const [cid, item] of oldFrameItems) {
      if (!this.frameItems.has(cid)) {
        this.addNotInUse(cid, item);
        oldFrameItems.delete(cid);
      }
    }
    for (const cid of this.notInUse.keys()) {
      this.updateNotInUse(cid);
    }
    setText("graph-fps-counter", inspector.fps.toFixed() + " FPS");
    setText(this.frameStats.data[1], frame.cpu.toFixed(2));
    setText(this.frameStats.data[2], frame.gpu.toFixed(2));
    setText(this.frameStats.data[3], frame.total.toFixed(2));
    setText(this.miscellaneous.data[1], frame.miscellaneous.toFixed(2));
    setText(this.miscellaneous.data[2], "-");
    setText(this.miscellaneous.data[3], frame.miscellaneous.toFixed(2));
    this.currentItem = null;
  }
};

// node_modules/three/examples/jsm/inspector/tabs/Console.js
var Console = class extends Tab {
  constructor() {
    super("Console");
    this.filters = { info: true, warn: true, error: true };
    this.filterText = "";
    this.buildHeader();
    this.logContainer = document.createElement("div");
    this.logContainer.id = "console-log";
    this.content.appendChild(this.logContainer);
  }
  buildHeader() {
    const header = document.createElement("div");
    header.className = "console-header";
    const filterInput = document.createElement("input");
    filterInput.type = "text";
    filterInput.className = "console-filter-input";
    filterInput.placeholder = "Filter...";
    filterInput.addEventListener("input", (e) => {
      this.filterText = e.target.value.toLowerCase();
      this.applyFilters();
    });
    const filtersGroup = document.createElement("div");
    filtersGroup.className = "console-filters-group";
    Object.keys(this.filters).forEach((type) => {
      const label = document.createElement("label");
      label.className = "custom-checkbox";
      label.style.color = `var(--${type === "info" ? "text-primary" : "color-" + (type === "warn" ? "yellow" : "red")})`;
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = this.filters[type];
      checkbox.dataset.type = type;
      const checkmark = document.createElement("span");
      checkmark.className = "checkmark";
      label.appendChild(checkbox);
      label.appendChild(checkmark);
      label.append(type.charAt(0).toUpperCase() + type.slice(1));
      filtersGroup.appendChild(label);
    });
    filtersGroup.addEventListener("change", (e) => {
      const type = e.target.dataset.type;
      if (type in this.filters) {
        this.filters[type] = e.target.checked;
        this.applyFilters();
      }
    });
    header.appendChild(filterInput);
    header.appendChild(filtersGroup);
    this.content.appendChild(header);
  }
  applyFilters() {
    const messages = this.logContainer.querySelectorAll(".log-message");
    messages.forEach((msg) => {
      const type = msg.dataset.type;
      const text = msg.dataset.rawText.toLowerCase();
      const showByType = this.filters[type];
      const showByText = text.includes(this.filterText);
      msg.classList.toggle("hidden", !(showByType && showByText));
    });
  }
  _getIcon(type, subType) {
    let icon;
    if (subType === "tip") {
      icon = "ðŸ’­";
    } else if (subType === "tsl") {
      icon = "âœ¨";
    } else if (subType === "webgpurenderer") {
      icon = "ðŸŽ¨";
    } else if (type === "warn") {
      icon = "âš ï¸";
    } else if (type === "error") {
      icon = "ðŸ”´";
    } else if (type === "info") {
      icon = "â„¹ï¸";
    }
    return icon;
  }
  _formatMessage(type, text) {
    const fragment = document.createDocumentFragment();
    const prefixMatch = text.match(/^([\w\.]+:\s)/);
    let content = text;
    if (prefixMatch) {
      const fullPrefix = prefixMatch[0];
      const parts2 = fullPrefix.slice(0, -2).split(".");
      const shortPrefix = (parts2.length > 1 ? parts2[parts2.length - 1] : parts2[0]) + ":";
      const icon = this._getIcon(type, shortPrefix.split(":")[0].toLowerCase());
      fragment.appendChild(document.createTextNode(icon + " "));
      const prefixSpan = document.createElement("span");
      prefixSpan.className = "log-prefix";
      prefixSpan.textContent = shortPrefix;
      fragment.appendChild(prefixSpan);
      content = text.substring(fullPrefix.length);
    }
    const parts = content.split(/(".*?"|'.*?'|`.*?`)/g).map((p) => p.trim()).filter(Boolean);
    parts.forEach((part, index) => {
      if (/^("|'|`)/.test(part)) {
        const codeSpan = document.createElement("span");
        codeSpan.className = "log-code";
        codeSpan.textContent = part.slice(1, -1);
        fragment.appendChild(codeSpan);
      } else {
        if (index > 0) part = " " + part;
        if (index < parts.length - 1) part += " ";
        fragment.appendChild(document.createTextNode(part));
      }
    });
    return fragment;
  }
  addMessage(type, text) {
    const msg = document.createElement("div");
    msg.className = `log-message ${type}`;
    msg.dataset.type = type;
    msg.dataset.rawText = text;
    msg.appendChild(this._formatMessage(type, text));
    const showByType = this.filters[type];
    const showByText = text.toLowerCase().includes(this.filterText);
    msg.classList.toggle("hidden", !(showByType && showByText));
    this.logContainer.appendChild(msg);
    this.logContainer.scrollTop = this.logContainer.scrollHeight;
    if (this.logContainer.children.length > 200) {
      this.logContainer.removeChild(this.logContainer.firstChild);
    }
  }
};

// node_modules/three/examples/jsm/inspector/ui/Values.js
var Value = class extends EventDispatcher {
  constructor() {
    super();
    this.domElement = document.createElement("div");
    this.domElement.className = "param-control";
    this._onChangeFunction = null;
    this.addEventListener("change", (e) => {
      requestAnimationFrame(() => {
        if (this._onChangeFunction) this._onChangeFunction(e.value);
      });
    });
  }
  setValue() {
    this.dispatchChange();
    return this;
  }
  getValue() {
    return null;
  }
  dispatchChange() {
    this.dispatchEvent({ type: "change", value: this.getValue() });
  }
  onChange(callback) {
    this._onChangeFunction = callback;
    return this;
  }
};
var ValueNumber = class extends Value {
  constructor({ value = 0, step = 0.1, min = -Infinity, max = Infinity }) {
    super();
    this.input = document.createElement("input");
    this.input.type = "number";
    this.input.value = value;
    this.input.step = step;
    this.input.min = min;
    this.input.max = max;
    this.input.addEventListener("change", this._onChangeValue.bind(this));
    this.domElement.appendChild(this.input);
    this.addDragHandler();
  }
  _onChangeValue() {
    const value = parseFloat(this.input.value);
    const min = parseFloat(this.input.min);
    const max = parseFloat(this.input.max);
    if (value > max) {
      this.input.value = max;
    } else if (value < min) {
      this.input.value = min;
    } else if (isNaN(value)) {
      this.input.value = min;
    }
    this.dispatchChange();
  }
  addDragHandler() {
    let isDragging = false;
    let startY, startValue;
    this.input.addEventListener("mousedown", (e) => {
      isDragging = true;
      startY = e.clientY;
      startValue = parseFloat(this.input.value);
      document.body.style.cursor = "ns-resize";
    });
    document.addEventListener("mousemove", (e) => {
      if (isDragging) {
        const deltaY = startY - e.clientY;
        const step = parseFloat(this.input.step) || 1;
        const min = parseFloat(this.input.min);
        const max = parseFloat(this.input.max);
        let stepSize = step;
        if (!isNaN(max) && isFinite(min)) {
          stepSize = (max - min) / 100;
        }
        const change = deltaY * stepSize;
        let newValue = startValue + change;
        newValue = Math.max(min, Math.min(newValue, max));
        const precision = (String(step).split(".")[1] || []).length;
        this.input.value = newValue.toFixed(precision);
        this.input.dispatchEvent(new Event("input"));
        this.dispatchChange();
      }
    });
    document.addEventListener("mouseup", () => {
      if (isDragging) {
        isDragging = false;
        document.body.style.cursor = "default";
      }
    });
  }
  getValue() {
    return parseFloat(this.input.value);
  }
};
var ValueCheckbox = class extends Value {
  constructor({ value = false }) {
    super();
    const label = document.createElement("label");
    label.className = "custom-checkbox";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = value;
    this.checkbox = checkbox;
    const checkmark = document.createElement("span");
    checkmark.className = "checkmark";
    label.appendChild(checkbox);
    label.appendChild(checkmark);
    this.domElement.appendChild(label);
    checkbox.addEventListener("change", () => {
      this.dispatchChange();
    });
  }
  getValue() {
    return this.checkbox.checked;
  }
};
var ValueSlider = class extends Value {
  constructor({ value = 0, min = 0, max = 1, step = 0.01 }) {
    super();
    this.slider = document.createElement("input");
    this.slider.type = "range";
    this.slider.min = min;
    this.slider.max = max;
    this.slider.step = step;
    const numberValue = new ValueNumber({ value, min, max, step });
    this.numberInput = numberValue.input;
    this.numberInput.style.width = "60px";
    this.numberInput.style.flexShrink = "0";
    this.slider.value = value;
    this.domElement.append(this.slider, this.numberInput);
    this.slider.addEventListener("input", () => {
      this.numberInput.value = this.slider.value;
      this.dispatchChange();
    });
    numberValue.addEventListener("change", () => {
      this.slider.value = parseFloat(this.numberInput.value);
      this.dispatchChange();
    });
  }
  setValue(val) {
    this.slider.value = val;
    this.numberInput.value = val;
    return super.setValue(val);
  }
  getValue() {
    return parseFloat(this.slider.value);
  }
  step(value) {
    this.slider.step = value;
    this.numberInput.step = value;
    return this;
  }
};
var ValueSelect = class extends Value {
  constructor({ options = [], value = "" }) {
    super();
    const select = document.createElement("select");
    const createOption = (name, optionValue) => {
      const optionEl = document.createElement("option");
      optionEl.value = name;
      optionEl.textContent = name;
      if (optionValue == value) optionEl.selected = true;
      select.appendChild(optionEl);
      return optionEl;
    };
    if (Array.isArray(options)) {
      options.forEach((opt) => createOption(opt, opt));
    } else {
      Object.entries(options).forEach(([key, value2]) => createOption(key, value2));
    }
    this.domElement.appendChild(select);
    select.addEventListener("change", () => {
      this.dispatchChange();
    });
    this.options = options;
    this.select = select;
  }
  getValue() {
    const options = this.options;
    if (Array.isArray(options)) {
      return options[this.select.selectedIndex];
    } else {
      return options[this.select.value];
    }
  }
};
var ValueColor = class extends Value {
  constructor({ value = "#ffffff" }) {
    super();
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = this._getColorHex(value);
    this.colorInput = colorInput;
    this._value = value;
    colorInput.addEventListener("input", () => {
      const colorValue = colorInput.value;
      if (this._value.isColor) {
        this._value.setHex(parseInt(colorValue.slice(1), 16));
      } else {
        this._value = colorValue;
      }
      this.dispatchChange();
    });
    this.domElement.appendChild(colorInput);
  }
  _getColorHex(color) {
    if (color.isColor) {
      color = color.getHex();
    }
    if (typeof color === "number") {
      color = `#${color.toString(16)}`;
    } else if (color[0] !== "#") {
      color = "#" + color;
    }
    return color;
  }
  getValue() {
    let value = this._value;
    if (typeof value === "string") {
      value = parseInt(value.slice(1), 16);
    }
    return value;
  }
};
var ValueButton = class extends Value {
  constructor({ text = "Button", value = () => {
  } }) {
    super();
    const button = document.createElement("button");
    button.textContent = text;
    button.onclick = value;
    this.domElement.appendChild(button);
  }
};

// node_modules/three/examples/jsm/inspector/tabs/Parameters.js
var ParametersGroup = class _ParametersGroup {
  constructor(parameters, name) {
    this.parameters = parameters;
    this.name = name;
    this.paramList = new Item(name);
  }
  close() {
    this.paramList.close();
    return this;
  }
  add(object, property, ...params) {
    const value = object[property];
    const type = typeof value;
    let item = null;
    if (typeof params[0] === "object") {
      item = this.addSelect(object, property, params[0]);
    } else if (type === "number") {
      if (params.length >= 2) {
        item = this.addSlider(object, property, ...params);
      } else {
        item = this.addNumber(object, property, ...params);
      }
    } else if (type === "boolean") {
      item = this.addBoolean(object, property);
    } else if (type === "function") {
      item = this.addButton(object, property, ...params);
    }
    return item;
  }
  _addParameter(object, property, editor, subItem) {
    editor.name = (name) => {
      subItem.data[0].textContent = name;
      return editor;
    };
    editor.listen = () => {
      const update = () => {
        const value = editor.getValue();
        const propertyValue = object[property];
        if (value !== propertyValue) {
          editor.setValue(propertyValue);
        }
        requestAnimationFrame(update);
      };
      requestAnimationFrame(update);
      return editor;
    };
  }
  addFolder(name) {
    const group = new _ParametersGroup(this.parameters, name);
    this.paramList.add(group.paramList);
    return group;
  }
  addBoolean(object, property) {
    const value = object[property];
    const editor = new ValueCheckbox({ value });
    editor.addEventListener("change", ({ value: value2 }) => {
      object[property] = value2;
    });
    const description = createValueSpan();
    description.textContent = property;
    const subItem = new Item(description, editor.domElement);
    this.paramList.add(subItem);
    const itemRow = subItem.domElement.firstChild;
    itemRow.classList.add("actionable");
    itemRow.addEventListener("click", (e) => {
      if (e.target.closest("label")) return;
      const checkbox = itemRow.querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event("change"));
      }
    });
    this._addParameter(object, property, editor, subItem);
    return editor;
  }
  addSelect(object, property, options) {
    const value = object[property];
    const editor = new ValueSelect({ options, value });
    editor.addEventListener("change", ({ value: value2 }) => {
      object[property] = value2;
    });
    const description = createValueSpan();
    description.textContent = property;
    const subItem = new Item(description, editor.domElement);
    this.paramList.add(subItem);
    const itemRow = subItem.domElement.firstChild;
    itemRow.classList.add("actionable");
    this._addParameter(object, property, editor, subItem);
    return editor;
  }
  addColor(object, property) {
    const value = object[property];
    const editor = new ValueColor({ value });
    editor.addEventListener("change", ({ value: value2 }) => {
      object[property] = value2;
    });
    const description = createValueSpan();
    description.textContent = property;
    const subItem = new Item(description, editor.domElement);
    this.paramList.add(subItem);
    const itemRow = subItem.domElement.firstChild;
    itemRow.classList.add("actionable");
    this._addParameter(object, property, editor, subItem);
    return editor;
  }
  addSlider(object, property, min = 0, max = 1, step = 0.01) {
    const value = object[property];
    const editor = new ValueSlider({ value, min, max, step });
    editor.addEventListener("change", ({ value: value2 }) => {
      object[property] = value2;
    });
    const description = createValueSpan();
    description.textContent = property;
    const subItem = new Item(description, editor.domElement);
    this.paramList.add(subItem);
    const itemRow = subItem.domElement.firstChild;
    itemRow.classList.add("actionable");
    this._addParameter(object, property, editor, subItem);
    return editor;
  }
  addNumber(object, property, ...params) {
    const value = object[property];
    const [min, max] = params;
    const editor = new ValueNumber({ value, min, max });
    editor.addEventListener("change", ({ value: value2 }) => {
      object[property] = value2;
    });
    const description = createValueSpan();
    description.textContent = property;
    const subItem = new Item(description, editor.domElement);
    this.paramList.add(subItem);
    const itemRow = subItem.domElement.firstChild;
    itemRow.classList.add("actionable");
    this._addParameter(object, property, editor, subItem);
    return editor;
  }
  addButton(object, property) {
    const value = object[property];
    const editor = new ValueButton({ text: property, value });
    editor.addEventListener("change", ({ value: value2 }) => {
      object[property] = value2;
    });
    const subItem = new Item(editor.domElement);
    subItem.itemRow.childNodes[0].style.gridColumn = "1 / -1";
    this.paramList.add(subItem);
    const itemRow = subItem.domElement.firstChild;
    itemRow.classList.add("actionable");
    editor.name = (name) => {
      editor.domElement.childNodes[0].textContent = name;
      return editor;
    };
    return editor;
  }
};
var Parameters = class extends Tab {
  constructor() {
    super("Parameters");
    const paramList = new List("Property", "Value");
    paramList.domElement.classList.add("parameters");
    paramList.setGridStyle(".5fr 1fr");
    paramList.domElement.style.minWidth = "300px";
    const scrollWrapper = document.createElement("div");
    scrollWrapper.className = "list-scroll-wrapper";
    scrollWrapper.appendChild(paramList.domElement);
    this.content.appendChild(scrollWrapper);
    this.paramList = paramList;
  }
  createGroup(name) {
    const group = new ParametersGroup(this, name);
    this.paramList.add(group.paramList);
    return group;
  }
};

// node_modules/three/examples/jsm/inspector/tabs/Viewer.js
var Viewer = class extends Tab {
  constructor() {
    super("Viewer");
    const nodeList = new List("Viewer", "Name");
    nodeList.setGridStyle("150px minmax(200px, 2fr)");
    nodeList.domElement.style.minWidth = "600px";
    const scrollWrapper = document.createElement("div");
    scrollWrapper.className = "list-scroll-wrapper";
    scrollWrapper.appendChild(nodeList.domElement);
    this.content.appendChild(scrollWrapper);
    const nodes = new Item("Nodes");
    nodeList.add(nodes);
    this.itemLibrary = /* @__PURE__ */ new Map();
    this.folderLibrary = /* @__PURE__ */ new Map();
    this.currentDataList = [];
    this.nodeList = nodeList;
    this.nodes = nodes;
  }
  getFolder(name) {
    let folder = this.folderLibrary.get(name);
    if (folder === void 0) {
      folder = new Item(name);
      this.folderLibrary.set(name, folder);
      this.nodeList.add(folder);
    }
    return folder;
  }
  addNodeItem(canvasData) {
    let item = this.itemLibrary.get(canvasData.id);
    if (item === void 0) {
      const name = canvasData.name;
      const domElement = canvasData.canvasTarget.domElement;
      item = new Item(domElement, name);
      item.itemRow.children[1].style["justify-content"] = "flex-start";
      this.itemLibrary.set(canvasData.id, item);
    }
    return item;
  }
  update(renderer, canvasDataList) {
    if (!this.isActive) return;
    const previousDataList = [...this.currentDataList];
    for (const canvasData of previousDataList) {
      if (this.itemLibrary.has(canvasData.id) && canvasDataList.indexOf(canvasData) === -1) {
        const item = this.itemLibrary.get(canvasData.id);
        const parent = item.parent;
        parent.remove(item);
        if (this.folderLibrary.has(parent.data[0]) && parent.children.length === 0) {
          parent.parent.remove(parent);
          this.folderLibrary.delete(parent.data[0]);
        }
        this.itemLibrary.delete(canvasData.id);
      }
    }
    const indexes = {};
    for (const canvasData of canvasDataList) {
      const item = this.addNodeItem(canvasData);
      const previousCanvasTarget = renderer.getCanvasTarget();
      const path = canvasData.path;
      if (path) {
        const folder = this.getFolder(path);
        if (indexes[path] === void 0) {
          indexes[path] = 0;
        }
        if (folder.parent === null || item.parent !== folder || folder.children.indexOf(item) !== indexes[path]) {
          folder.add(item);
        }
        indexes[path]++;
      } else {
        if (!item.parent) {
          this.nodes.add(item);
        }
      }
      this.currentDataList = canvasDataList;
      const state = RendererUtils.resetRendererState(renderer);
      renderer.toneMapping = NoToneMapping;
      renderer.outputColorSpace = LinearSRGBColorSpace;
      renderer.setCanvasTarget(canvasData.canvasTarget);
      canvasData.quad.render(renderer);
      renderer.setCanvasTarget(previousCanvasTarget);
      RendererUtils.restoreRendererState(renderer, state);
    }
  }
};

// node_modules/three/examples/jsm/inspector/Inspector.js
var Inspector = class extends RendererInspector {
  constructor() {
    super();
    const profiler = new Profiler();
    const parameters = new Parameters();
    parameters.hide();
    profiler.addTab(parameters);
    const viewer = new Viewer();
    viewer.hide();
    profiler.addTab(viewer);
    const performance2 = new Performance();
    profiler.addTab(performance2);
    const console2 = new Console();
    profiler.addTab(console2);
    profiler.setActiveTab(performance2.id);
    this.statsData = /* @__PURE__ */ new Map();
    this.canvasNodes = /* @__PURE__ */ new Map();
    this.profiler = profiler;
    this.performance = performance2;
    this.console = console2;
    this.parameters = parameters;
    this.viewer = viewer;
    this.once = {};
    this.displayCycle = {
      text: {
        needsUpdate: false,
        duration: 0.25,
        time: 0
      },
      graph: {
        needsUpdate: false,
        duration: 0.02,
        time: 0
      }
    };
  }
  get domElement() {
    return this.profiler.domElement;
  }
  resolveConsoleOnce(type, message) {
    const key = type + message;
    if (this.once[key] !== true) {
      this.resolveConsole(type, message);
      this.once[key] = true;
    }
  }
  resolveConsole(type, message) {
    switch (type) {
      case "log":
        this.console.addMessage("info", message);
        console.log(message);
        break;
      case "warn":
        this.console.addMessage("warn", message);
        console.warn(message);
        break;
      case "error":
        this.console.addMessage("error", message);
        console.error(message);
        break;
    }
  }
  init() {
    const renderer = this.getRenderer();
    let sign = `THREE.WebGPURenderer: ${REVISION} [ "`;
    if (renderer.backend.isWebGPUBackend) {
      sign += "WebGPU";
    } else if (renderer.backend.isWebGLBackend) {
      sign += "WebGL2";
    }
    sign += '" ]';
    this.console.addMessage("info", sign);
    if (renderer.inspector.domElement.parentElement === null && renderer.domElement.parentElement !== null) {
      renderer.domElement.parentElement.appendChild(renderer.inspector.domElement);
    }
  }
  setRenderer(renderer) {
    super.setRenderer(renderer);
    if (renderer !== null) {
      setConsoleFunction(this.resolveConsole.bind(this));
      if (this.isAvailable) {
        renderer.backend.trackTimestamp = true;
        renderer.init().then(() => {
          if (renderer.hasFeature("timestamp-query") !== true) {
            this.console.addMessage("error", "THREE.Inspector: GPU Timestamp Queries not available.");
          }
        });
      }
    }
    return this;
  }
  createParameters(name) {
    if (this.parameters.isVisible === false) {
      this.parameters.show();
      this.profiler.setActiveTab(this.parameters.id);
    }
    return this.parameters.createGroup(name);
  }
  getStatsData(cid) {
    let data = this.statsData.get(cid);
    if (data === void 0) {
      data = {};
      this.statsData.set(cid, data);
    }
    return data;
  }
  resolveStats(stats) {
    const data = this.getStatsData(stats.cid);
    if (data.initialized !== true) {
      data.cpu = stats.cpu;
      data.gpu = stats.gpu;
      data.stats = [];
      data.initialized = true;
    }
    if (data.stats.length > this.maxFrames) {
      data.stats.shift();
    }
    data.stats.push(stats);
    data.cpu = this.getAverageDeltaTime(data, "cpu");
    data.gpu = this.getAverageDeltaTime(data, "gpu");
    data.total = data.cpu + data.gpu;
    for (const child of stats.children) {
      this.resolveStats(child);
      const childData = this.getStatsData(child.cid);
      data.cpu += childData.cpu;
      data.gpu += childData.gpu;
      data.total += childData.total;
    }
  }
  getCanvasDataByNode(node) {
    let canvasData = this.canvasNodes.get(node);
    if (canvasData === void 0) {
      const renderer = this.getRenderer();
      const canvas = document.createElement("canvas");
      const canvasTarget = new CanvasTarget(canvas);
      canvasTarget.setPixelRatio(window.devicePixelRatio);
      canvasTarget.setSize(140, 140);
      const id = node.id;
      const { path, name } = splitPath(splitCamelCase(node.getName() || "(unnamed)"));
      let output = vec4(vec3(node), 1);
      output = renderOutput(output, NoToneMapping, renderer.outputColorSpace);
      output = output.context({ inspector: true });
      const material = new NodeMaterial();
      material.outputNode = output;
      const quad = new QuadMesh(material);
      quad.name = "Viewer - " + name;
      canvasData = {
        id,
        name,
        path,
        node,
        quad,
        canvasTarget,
        material
      };
      this.canvasNodes.set(node, canvasData);
    }
    return canvasData;
  }
  resolveViewer() {
    const nodes = this.currentNodes;
    const renderer = this.getRenderer();
    if (nodes.length === 0) return;
    if (!renderer.backend.isWebGPUBackend) {
      this.resolveConsoleOnce("warn", "Inspector: Viewer is only available with WebGPU.");
      return;
    }
    if (!this.viewer.isVisible) {
      this.viewer.show();
    }
    const canvasDataList = nodes.map((node) => this.getCanvasDataByNode(node));
    this.viewer.update(renderer, canvasDataList);
  }
  getAverageDeltaTime(statsData, property, frames = this.fps) {
    const statsArray = statsData.stats;
    let sum = 0;
    let count = 0;
    for (let i = statsArray.length - 1; i >= 0 && count < frames; i--) {
      const stats = statsArray[i];
      const value = stats[property];
      if (value > 0) {
        sum += value;
        count++;
      }
    }
    return count > 0 ? sum / count : 0;
  }
  resolveFrame(frame) {
    const nextFrame = this.getFrameById(frame.frameId + 1);
    if (!nextFrame) return;
    frame.cpu = 0;
    frame.gpu = 0;
    frame.total = 0;
    for (const stats of frame.children) {
      this.resolveStats(stats);
      const data = this.getStatsData(stats.cid);
      frame.cpu += data.cpu;
      frame.gpu += data.gpu;
      frame.total += data.total;
    }
    frame.deltaTime = nextFrame.startTime - frame.startTime;
    frame.miscellaneous = frame.deltaTime - frame.total;
    if (frame.miscellaneous < 0) {
      frame.miscellaneous = 0;
    }
    this.updateCycle(this.displayCycle.text);
    this.updateCycle(this.displayCycle.graph);
    if (this.displayCycle.text.needsUpdate) {
      setText("fps-counter", this.fps.toFixed());
      this.performance.updateText(this, frame);
    }
    if (this.displayCycle.graph.needsUpdate) {
      this.performance.updateGraph(this, frame);
    }
    this.displayCycle.text.needsUpdate = false;
    this.displayCycle.graph.needsUpdate = false;
  }
  updateCycle(cycle) {
    cycle.time += this.nodeFrame.deltaTime;
    if (cycle.time >= cycle.duration) {
      cycle.needsUpdate = true;
      cycle.time = 0;
    }
  }
};
export {
  Inspector
};
//# sourceMappingURL=three_addons_inspector_Inspector__js.js.map
